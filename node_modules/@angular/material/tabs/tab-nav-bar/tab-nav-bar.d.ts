/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { Directionality } from '@angular/cdk/bidi';
import { Platform } from '@angular/cdk/platform';
import { ViewportRuler } from '@angular/cdk/scrolling';
import { AfterContentChecked, AfterContentInit, ChangeDetectorRef, ElementRef, NgZone, OnDestroy, QueryList } from '@angular/core';
import { CanDisable, CanDisableCtor, CanDisableRipple, CanDisableRippleCtor, HasTabIndex, HasTabIndexCtor, RippleConfig, RippleGlobalOptions, RippleTarget, ThemePalette } from '@angular/material/core';
import { BooleanInput } from '@angular/cdk/coercion';
import { FocusMonitor, FocusableOption } from '@angular/cdk/a11y';
import { MatInkBar } from '../ink-bar';
import { MatPaginatedTabHeader, MatPaginatedTabHeaderItem } from '../paginated-tab-header';
/**
 * Base class with all of the `MatTabNav` functionality.
 * @docs-private
 */
import * as ɵngcc0 from '@angular/core';
export declare abstract class _MatTabNavBase extends MatPaginatedTabHeader implements AfterContentChecked, AfterContentInit, OnDestroy {
    /** Query list of all tab links of the tab navigation. */
    abstract _items: QueryList<MatPaginatedTabHeaderItem & {
        active: boolean;
    }>;
    /** Background color of the tab nav. */
    get backgroundColor(): ThemePalette;
    set backgroundColor(value: ThemePalette);
    private _backgroundColor;
    /** Whether the ripple effect is disabled or not. */
    get disableRipple(): any;
    set disableRipple(value: any);
    private _disableRipple;
    /** Theme color of the nav bar. */
    color: ThemePalette;
    constructor(elementRef: ElementRef, dir: Directionality, ngZone: NgZone, changeDetectorRef: ChangeDetectorRef, viewportRuler: ViewportRuler, 
    /**
     * @deprecated @breaking-change 9.0.0 `platform` parameter to become required.
     */
    platform?: Platform, animationMode?: string);
    protected _itemSelected(): void;
    ngAfterContentInit(): void;
    /**
     * Notifies the component that the active link has been changed.
     * @breaking-change 8.0.0 `element` parameter to be removed.
     */
    updateActiveLink(_element?: ElementRef): void;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<_MatTabNavBase>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<_MatTabNavBase, never, never, {
    "color": "color";
    "backgroundColor": "backgroundColor";
    "disableRipple": "disableRipple";
}, {}, never>;
}
/**
 * Navigation component matching the styles of the tab group header.
 * Provides anchored navigation with animated ink bar.
 */
export declare class MatTabNav extends _MatTabNavBase {
    _items: QueryList<MatTabLink>;
    _inkBar: MatInkBar;
    _tabListContainer: ElementRef;
    _tabList: ElementRef;
    _nextPaginator: ElementRef<HTMLElement>;
    _previousPaginator: ElementRef<HTMLElement>;
    constructor(elementRef: ElementRef, dir: Directionality, ngZone: NgZone, changeDetectorRef: ChangeDetectorRef, viewportRuler: ViewportRuler, 
    /**
     * @deprecated @breaking-change 9.0.0 `platform` parameter to become required.
     */
    platform?: Platform, animationMode?: string);
    static ngAcceptInputType_disableRipple: BooleanInput;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<MatTabNav>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<MatTabNav, "[mat-tab-nav-bar]", ["matTabNavBar", "matTabNav"], {
    "color": "color";
}, {}, ["_items"]>;
}
declare class MatTabLinkMixinBase {
}
declare const _MatTabLinkMixinBase: HasTabIndexCtor & CanDisableRippleCtor & CanDisableCtor & typeof MatTabLinkMixinBase;
/** Base class with all of the `MatTabLink` functionality. */
export declare class _MatTabLinkBase extends _MatTabLinkMixinBase implements OnDestroy, CanDisable, CanDisableRipple, HasTabIndex, RippleTarget, FocusableOption {
    private _tabNavBar;
    elementRef: ElementRef;
    private _focusMonitor;
    /** Whether the tab link is active or not. */
    protected _isActive: boolean;
    /** Whether the link is active. */
    get active(): boolean;
    set active(value: boolean);
    /**
     * Ripple configuration for ripples that are launched on pointer down. The ripple config
     * is set to the global ripple options since we don't have any configurable options for
     * the tab link ripples.
     * @docs-private
     */
    rippleConfig: RippleConfig & RippleGlobalOptions;
    /**
     * Whether ripples are disabled on interaction.
     * @docs-private
     */
    get rippleDisabled(): boolean;
    constructor(_tabNavBar: _MatTabNavBase, elementRef: ElementRef, globalRippleOptions: RippleGlobalOptions | null, tabIndex: string, _focusMonitor: FocusMonitor, animationMode?: string);
    focus(): void;
    ngOnDestroy(): void;
    static ngAcceptInputType_disabled: BooleanInput;
    static ngAcceptInputType_disableRipple: BooleanInput;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<_MatTabLinkBase>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<_MatTabLinkBase, never, never, {
    "active": "active";
}, {}, never>;
}
/**
 * Link inside of a `mat-tab-nav-bar`.
 */
export declare class MatTabLink extends _MatTabLinkBase implements OnDestroy {
    /** Reference to the RippleRenderer for the tab-link. */
    private _tabLinkRipple;
    constructor(tabNavBar: MatTabNav, elementRef: ElementRef, ngZone: NgZone, platform: Platform, globalRippleOptions: RippleGlobalOptions | null, tabIndex: string, focusMonitor: FocusMonitor, animationMode?: string);
    ngOnDestroy(): void;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<MatTabLink>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<MatTabLink, "[mat-tab-link], [matTabLink]", ["matTabLink"], {
    "disabled": "disabled";
    "disableRipple": "disableRipple";
    "tabIndex": "tabIndex";
}, {}, never>;
}
export {};

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGFiLW5hdi1iYXIuZC50cyIsInNvdXJjZXMiOlsidGFiLW5hdi1iYXIuZC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBb0JBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUEyQkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFrQkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBK0JBOzs7Ozs7Ozs7Ozs7Ozs7QUFTQSIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxyXG4gKlxyXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxyXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXHJcbiAqL1xyXG5pbXBvcnQgeyBEaXJlY3Rpb25hbGl0eSB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9iaWRpJztcclxuaW1wb3J0IHsgUGxhdGZvcm0gfSBmcm9tICdAYW5ndWxhci9jZGsvcGxhdGZvcm0nO1xyXG5pbXBvcnQgeyBWaWV3cG9ydFJ1bGVyIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL3Njcm9sbGluZyc7XHJcbmltcG9ydCB7IEFmdGVyQ29udGVudENoZWNrZWQsIEFmdGVyQ29udGVudEluaXQsIENoYW5nZURldGVjdG9yUmVmLCBFbGVtZW50UmVmLCBOZ1pvbmUsIE9uRGVzdHJveSwgUXVlcnlMaXN0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IENhbkRpc2FibGUsIENhbkRpc2FibGVDdG9yLCBDYW5EaXNhYmxlUmlwcGxlLCBDYW5EaXNhYmxlUmlwcGxlQ3RvciwgSGFzVGFiSW5kZXgsIEhhc1RhYkluZGV4Q3RvciwgUmlwcGxlQ29uZmlnLCBSaXBwbGVHbG9iYWxPcHRpb25zLCBSaXBwbGVUYXJnZXQsIFRoZW1lUGFsZXR0ZSB9IGZyb20gJ0Bhbmd1bGFyL21hdGVyaWFsL2NvcmUnO1xyXG5pbXBvcnQgeyBCb29sZWFuSW5wdXQgfSBmcm9tICdAYW5ndWxhci9jZGsvY29lcmNpb24nO1xyXG5pbXBvcnQgeyBGb2N1c01vbml0b3IsIEZvY3VzYWJsZU9wdGlvbiB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9hMTF5JztcclxuaW1wb3J0IHsgTWF0SW5rQmFyIH0gZnJvbSAnLi4vaW5rLWJhcic7XHJcbmltcG9ydCB7IE1hdFBhZ2luYXRlZFRhYkhlYWRlciwgTWF0UGFnaW5hdGVkVGFiSGVhZGVySXRlbSB9IGZyb20gJy4uL3BhZ2luYXRlZC10YWItaGVhZGVyJztcclxuLyoqXHJcbiAqIEJhc2UgY2xhc3Mgd2l0aCBhbGwgb2YgdGhlIGBNYXRUYWJOYXZgIGZ1bmN0aW9uYWxpdHkuXHJcbiAqIEBkb2NzLXByaXZhdGVcclxuICovXHJcbmV4cG9ydCBkZWNsYXJlIGFic3RyYWN0IGNsYXNzIF9NYXRUYWJOYXZCYXNlIGV4dGVuZHMgTWF0UGFnaW5hdGVkVGFiSGVhZGVyIGltcGxlbWVudHMgQWZ0ZXJDb250ZW50Q2hlY2tlZCwgQWZ0ZXJDb250ZW50SW5pdCwgT25EZXN0cm95IHtcclxuICAgIC8qKiBRdWVyeSBsaXN0IG9mIGFsbCB0YWIgbGlua3Mgb2YgdGhlIHRhYiBuYXZpZ2F0aW9uLiAqL1xyXG4gICAgYWJzdHJhY3QgX2l0ZW1zOiBRdWVyeUxpc3Q8TWF0UGFnaW5hdGVkVGFiSGVhZGVySXRlbSAmIHtcclxuICAgICAgICBhY3RpdmU6IGJvb2xlYW47XHJcbiAgICB9PjtcclxuICAgIC8qKiBCYWNrZ3JvdW5kIGNvbG9yIG9mIHRoZSB0YWIgbmF2LiAqL1xyXG4gICAgZ2V0IGJhY2tncm91bmRDb2xvcigpOiBUaGVtZVBhbGV0dGU7XHJcbiAgICBzZXQgYmFja2dyb3VuZENvbG9yKHZhbHVlOiBUaGVtZVBhbGV0dGUpO1xyXG4gICAgcHJpdmF0ZSBfYmFja2dyb3VuZENvbG9yO1xyXG4gICAgLyoqIFdoZXRoZXIgdGhlIHJpcHBsZSBlZmZlY3QgaXMgZGlzYWJsZWQgb3Igbm90LiAqL1xyXG4gICAgZ2V0IGRpc2FibGVSaXBwbGUoKTogYW55O1xyXG4gICAgc2V0IGRpc2FibGVSaXBwbGUodmFsdWU6IGFueSk7XHJcbiAgICBwcml2YXRlIF9kaXNhYmxlUmlwcGxlO1xyXG4gICAgLyoqIFRoZW1lIGNvbG9yIG9mIHRoZSBuYXYgYmFyLiAqL1xyXG4gICAgY29sb3I6IFRoZW1lUGFsZXR0ZTtcclxuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnRSZWY6IEVsZW1lbnRSZWYsIGRpcjogRGlyZWN0aW9uYWxpdHksIG5nWm9uZTogTmdab25lLCBjaGFuZ2VEZXRlY3RvclJlZjogQ2hhbmdlRGV0ZWN0b3JSZWYsIHZpZXdwb3J0UnVsZXI6IFZpZXdwb3J0UnVsZXIsIFxyXG4gICAgLyoqXHJcbiAgICAgKiBAZGVwcmVjYXRlZCBAYnJlYWtpbmctY2hhbmdlIDkuMC4wIGBwbGF0Zm9ybWAgcGFyYW1ldGVyIHRvIGJlY29tZSByZXF1aXJlZC5cclxuICAgICAqL1xyXG4gICAgcGxhdGZvcm0/OiBQbGF0Zm9ybSwgYW5pbWF0aW9uTW9kZT86IHN0cmluZyk7XHJcbiAgICBwcm90ZWN0ZWQgX2l0ZW1TZWxlY3RlZCgpOiB2b2lkO1xyXG4gICAgbmdBZnRlckNvbnRlbnRJbml0KCk6IHZvaWQ7XHJcbiAgICAvKipcclxuICAgICAqIE5vdGlmaWVzIHRoZSBjb21wb25lbnQgdGhhdCB0aGUgYWN0aXZlIGxpbmsgaGFzIGJlZW4gY2hhbmdlZC5cclxuICAgICAqIEBicmVha2luZy1jaGFuZ2UgOC4wLjAgYGVsZW1lbnRgIHBhcmFtZXRlciB0byBiZSByZW1vdmVkLlxyXG4gICAgICovXHJcbiAgICB1cGRhdGVBY3RpdmVMaW5rKF9lbGVtZW50PzogRWxlbWVudFJlZik6IHZvaWQ7XHJcbn1cclxuLyoqXHJcbiAqIE5hdmlnYXRpb24gY29tcG9uZW50IG1hdGNoaW5nIHRoZSBzdHlsZXMgb2YgdGhlIHRhYiBncm91cCBoZWFkZXIuXHJcbiAqIFByb3ZpZGVzIGFuY2hvcmVkIG5hdmlnYXRpb24gd2l0aCBhbmltYXRlZCBpbmsgYmFyLlxyXG4gKi9cclxuZXhwb3J0IGRlY2xhcmUgY2xhc3MgTWF0VGFiTmF2IGV4dGVuZHMgX01hdFRhYk5hdkJhc2Uge1xyXG4gICAgX2l0ZW1zOiBRdWVyeUxpc3Q8TWF0VGFiTGluaz47XHJcbiAgICBfaW5rQmFyOiBNYXRJbmtCYXI7XHJcbiAgICBfdGFiTGlzdENvbnRhaW5lcjogRWxlbWVudFJlZjtcclxuICAgIF90YWJMaXN0OiBFbGVtZW50UmVmO1xyXG4gICAgX25leHRQYWdpbmF0b3I6IEVsZW1lbnRSZWY8SFRNTEVsZW1lbnQ+O1xyXG4gICAgX3ByZXZpb3VzUGFnaW5hdG9yOiBFbGVtZW50UmVmPEhUTUxFbGVtZW50PjtcclxuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnRSZWY6IEVsZW1lbnRSZWYsIGRpcjogRGlyZWN0aW9uYWxpdHksIG5nWm9uZTogTmdab25lLCBjaGFuZ2VEZXRlY3RvclJlZjogQ2hhbmdlRGV0ZWN0b3JSZWYsIHZpZXdwb3J0UnVsZXI6IFZpZXdwb3J0UnVsZXIsIFxyXG4gICAgLyoqXHJcbiAgICAgKiBAZGVwcmVjYXRlZCBAYnJlYWtpbmctY2hhbmdlIDkuMC4wIGBwbGF0Zm9ybWAgcGFyYW1ldGVyIHRvIGJlY29tZSByZXF1aXJlZC5cclxuICAgICAqL1xyXG4gICAgcGxhdGZvcm0/OiBQbGF0Zm9ybSwgYW5pbWF0aW9uTW9kZT86IHN0cmluZyk7XHJcbiAgICBzdGF0aWMgbmdBY2NlcHRJbnB1dFR5cGVfZGlzYWJsZVJpcHBsZTogQm9vbGVhbklucHV0O1xyXG59XHJcbmRlY2xhcmUgY2xhc3MgTWF0VGFiTGlua01peGluQmFzZSB7XHJcbn1cclxuZGVjbGFyZSBjb25zdCBfTWF0VGFiTGlua01peGluQmFzZTogSGFzVGFiSW5kZXhDdG9yICYgQ2FuRGlzYWJsZVJpcHBsZUN0b3IgJiBDYW5EaXNhYmxlQ3RvciAmIHR5cGVvZiBNYXRUYWJMaW5rTWl4aW5CYXNlO1xyXG4vKiogQmFzZSBjbGFzcyB3aXRoIGFsbCBvZiB0aGUgYE1hdFRhYkxpbmtgIGZ1bmN0aW9uYWxpdHkuICovXHJcbmV4cG9ydCBkZWNsYXJlIGNsYXNzIF9NYXRUYWJMaW5rQmFzZSBleHRlbmRzIF9NYXRUYWJMaW5rTWl4aW5CYXNlIGltcGxlbWVudHMgT25EZXN0cm95LCBDYW5EaXNhYmxlLCBDYW5EaXNhYmxlUmlwcGxlLCBIYXNUYWJJbmRleCwgUmlwcGxlVGFyZ2V0LCBGb2N1c2FibGVPcHRpb24ge1xyXG4gICAgcHJpdmF0ZSBfdGFiTmF2QmFyO1xyXG4gICAgZWxlbWVudFJlZjogRWxlbWVudFJlZjtcclxuICAgIHByaXZhdGUgX2ZvY3VzTW9uaXRvcjtcclxuICAgIC8qKiBXaGV0aGVyIHRoZSB0YWIgbGluayBpcyBhY3RpdmUgb3Igbm90LiAqL1xyXG4gICAgcHJvdGVjdGVkIF9pc0FjdGl2ZTogYm9vbGVhbjtcclxuICAgIC8qKiBXaGV0aGVyIHRoZSBsaW5rIGlzIGFjdGl2ZS4gKi9cclxuICAgIGdldCBhY3RpdmUoKTogYm9vbGVhbjtcclxuICAgIHNldCBhY3RpdmUodmFsdWU6IGJvb2xlYW4pO1xyXG4gICAgLyoqXHJcbiAgICAgKiBSaXBwbGUgY29uZmlndXJhdGlvbiBmb3IgcmlwcGxlcyB0aGF0IGFyZSBsYXVuY2hlZCBvbiBwb2ludGVyIGRvd24uIFRoZSByaXBwbGUgY29uZmlnXHJcbiAgICAgKiBpcyBzZXQgdG8gdGhlIGdsb2JhbCByaXBwbGUgb3B0aW9ucyBzaW5jZSB3ZSBkb24ndCBoYXZlIGFueSBjb25maWd1cmFibGUgb3B0aW9ucyBmb3JcclxuICAgICAqIHRoZSB0YWIgbGluayByaXBwbGVzLlxyXG4gICAgICogQGRvY3MtcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICByaXBwbGVDb25maWc6IFJpcHBsZUNvbmZpZyAmIFJpcHBsZUdsb2JhbE9wdGlvbnM7XHJcbiAgICAvKipcclxuICAgICAqIFdoZXRoZXIgcmlwcGxlcyBhcmUgZGlzYWJsZWQgb24gaW50ZXJhY3Rpb24uXHJcbiAgICAgKiBAZG9jcy1wcml2YXRlXHJcbiAgICAgKi9cclxuICAgIGdldCByaXBwbGVEaXNhYmxlZCgpOiBib29sZWFuO1xyXG4gICAgY29uc3RydWN0b3IoX3RhYk5hdkJhcjogX01hdFRhYk5hdkJhc2UsIGVsZW1lbnRSZWY6IEVsZW1lbnRSZWYsIGdsb2JhbFJpcHBsZU9wdGlvbnM6IFJpcHBsZUdsb2JhbE9wdGlvbnMgfCBudWxsLCB0YWJJbmRleDogc3RyaW5nLCBfZm9jdXNNb25pdG9yOiBGb2N1c01vbml0b3IsIGFuaW1hdGlvbk1vZGU/OiBzdHJpbmcpO1xyXG4gICAgZm9jdXMoKTogdm9pZDtcclxuICAgIG5nT25EZXN0cm95KCk6IHZvaWQ7XHJcbiAgICBzdGF0aWMgbmdBY2NlcHRJbnB1dFR5cGVfZGlzYWJsZWQ6IEJvb2xlYW5JbnB1dDtcclxuICAgIHN0YXRpYyBuZ0FjY2VwdElucHV0VHlwZV9kaXNhYmxlUmlwcGxlOiBCb29sZWFuSW5wdXQ7XHJcbn1cclxuLyoqXHJcbiAqIExpbmsgaW5zaWRlIG9mIGEgYG1hdC10YWItbmF2LWJhcmAuXHJcbiAqL1xyXG5leHBvcnQgZGVjbGFyZSBjbGFzcyBNYXRUYWJMaW5rIGV4dGVuZHMgX01hdFRhYkxpbmtCYXNlIGltcGxlbWVudHMgT25EZXN0cm95IHtcclxuICAgIC8qKiBSZWZlcmVuY2UgdG8gdGhlIFJpcHBsZVJlbmRlcmVyIGZvciB0aGUgdGFiLWxpbmsuICovXHJcbiAgICBwcml2YXRlIF90YWJMaW5rUmlwcGxlO1xyXG4gICAgY29uc3RydWN0b3IodGFiTmF2QmFyOiBNYXRUYWJOYXYsIGVsZW1lbnRSZWY6IEVsZW1lbnRSZWYsIG5nWm9uZTogTmdab25lLCBwbGF0Zm9ybTogUGxhdGZvcm0sIGdsb2JhbFJpcHBsZU9wdGlvbnM6IFJpcHBsZUdsb2JhbE9wdGlvbnMgfCBudWxsLCB0YWJJbmRleDogc3RyaW5nLCBmb2N1c01vbml0b3I6IEZvY3VzTW9uaXRvciwgYW5pbWF0aW9uTW9kZT86IHN0cmluZyk7XHJcbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkO1xyXG59XHJcbmV4cG9ydCB7fTtcclxuIl19