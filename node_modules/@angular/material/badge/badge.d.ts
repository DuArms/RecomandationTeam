/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { AriaDescriber } from '@angular/cdk/a11y';
import { BooleanInput } from '@angular/cdk/coercion';
import { ElementRef, NgZone, OnChanges, OnDestroy, Renderer2, SimpleChanges } from '@angular/core';
import { CanDisable, CanDisableCtor, ThemePalette } from '@angular/material/core';
/** @docs-private */
import * as ɵngcc0 from '@angular/core';
declare class MatBadgeBase {
}
declare const _MatBadgeMixinBase: CanDisableCtor & typeof MatBadgeBase;
/** Allowed position options for matBadgePosition */
export declare type MatBadgePosition = 'above after' | 'above before' | 'below before' | 'below after' | 'before' | 'after' | 'above' | 'below';
/** Allowed size options for matBadgeSize */
export declare type MatBadgeSize = 'small' | 'medium' | 'large';
/** Directive to display a text badge. */
export declare class MatBadge extends _MatBadgeMixinBase implements OnDestroy, OnChanges, CanDisable {
    private _ngZone;
    private _elementRef;
    private _ariaDescriber;
    private _renderer;
    private _animationMode?;
    /** Whether the badge has any content. */
    _hasContent: boolean;
    /** The color of the badge. Can be `primary`, `accent`, or `warn`. */
    get color(): ThemePalette;
    set color(value: ThemePalette);
    private _color;
    /** Whether the badge should overlap its contents or not */
    get overlap(): boolean;
    set overlap(val: boolean);
    private _overlap;
    /**
     * Position the badge should reside.
     * Accepts any combination of 'above'|'below' and 'before'|'after'
     */
    position: MatBadgePosition;
    /** The content for the badge */
    content: string;
    /** Message used to describe the decorated element via aria-describedby */
    get description(): string;
    set description(newDescription: string);
    private _description;
    /** Size of the badge. Can be 'small', 'medium', or 'large'. */
    size: MatBadgeSize;
    /** Whether the badge is hidden. */
    get hidden(): boolean;
    set hidden(val: boolean);
    private _hidden;
    /** Unique id for the badge */
    _id: number;
    private _badgeElement;
    constructor(_ngZone: NgZone, _elementRef: ElementRef<HTMLElement>, _ariaDescriber: AriaDescriber, _renderer: Renderer2, _animationMode?: string | undefined);
    /** Whether the badge is above the host or not */
    isAbove(): boolean;
    /** Whether the badge is after the host or not */
    isAfter(): boolean;
    ngOnChanges(changes: SimpleChanges): void;
    ngOnDestroy(): void;
    /**
     * Gets the element into which the badge's content is being rendered.
     * Undefined if the element hasn't been created (e.g. if the badge doesn't have content).
     */
    getBadgeElement(): HTMLElement | undefined;
    /** Injects a span element into the DOM with the content. */
    private _updateTextContent;
    /** Creates the badge element */
    private _createBadgeElement;
    /** Sets the aria-label property on the element */
    private _updateHostAriaDescription;
    /** Adds css theme class given the color to the component host */
    private _setColor;
    /** Clears any existing badges that might be left over from server-side rendering. */
    private _clearExistingBadges;
    static ngAcceptInputType_disabled: BooleanInput;
    static ngAcceptInputType_hidden: BooleanInput;
    static ngAcceptInputType_overlap: BooleanInput;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<MatBadge>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<MatBadge, "[matBadge]", never, {
    "disabled": "matBadgeDisabled";
    "position": "matBadgePosition";
    "size": "matBadgeSize";
    "color": "matBadgeColor";
    "overlap": "matBadgeOverlap";
    "description": "matBadgeDescription";
    "hidden": "matBadgeHidden";
    "content": "matBadge";
}, {}, never>;
}
export {};

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFkZ2UuZC50cyIsInNvdXJjZXMiOlsiYmFkZ2UuZC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7OztBQVlBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXFFQSIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxyXG4gKlxyXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxyXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXHJcbiAqL1xyXG5pbXBvcnQgeyBBcmlhRGVzY3JpYmVyIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2ExMXknO1xyXG5pbXBvcnQgeyBCb29sZWFuSW5wdXQgfSBmcm9tICdAYW5ndWxhci9jZGsvY29lcmNpb24nO1xyXG5pbXBvcnQgeyBFbGVtZW50UmVmLCBOZ1pvbmUsIE9uQ2hhbmdlcywgT25EZXN0cm95LCBSZW5kZXJlcjIsIFNpbXBsZUNoYW5nZXMgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgQ2FuRGlzYWJsZSwgQ2FuRGlzYWJsZUN0b3IsIFRoZW1lUGFsZXR0ZSB9IGZyb20gJ0Bhbmd1bGFyL21hdGVyaWFsL2NvcmUnO1xyXG4vKiogQGRvY3MtcHJpdmF0ZSAqL1xyXG5kZWNsYXJlIGNsYXNzIE1hdEJhZGdlQmFzZSB7XHJcbn1cclxuZGVjbGFyZSBjb25zdCBfTWF0QmFkZ2VNaXhpbkJhc2U6IENhbkRpc2FibGVDdG9yICYgdHlwZW9mIE1hdEJhZGdlQmFzZTtcclxuLyoqIEFsbG93ZWQgcG9zaXRpb24gb3B0aW9ucyBmb3IgbWF0QmFkZ2VQb3NpdGlvbiAqL1xyXG5leHBvcnQgZGVjbGFyZSB0eXBlIE1hdEJhZGdlUG9zaXRpb24gPSAnYWJvdmUgYWZ0ZXInIHwgJ2Fib3ZlIGJlZm9yZScgfCAnYmVsb3cgYmVmb3JlJyB8ICdiZWxvdyBhZnRlcicgfCAnYmVmb3JlJyB8ICdhZnRlcicgfCAnYWJvdmUnIHwgJ2JlbG93JztcclxuLyoqIEFsbG93ZWQgc2l6ZSBvcHRpb25zIGZvciBtYXRCYWRnZVNpemUgKi9cclxuZXhwb3J0IGRlY2xhcmUgdHlwZSBNYXRCYWRnZVNpemUgPSAnc21hbGwnIHwgJ21lZGl1bScgfCAnbGFyZ2UnO1xyXG4vKiogRGlyZWN0aXZlIHRvIGRpc3BsYXkgYSB0ZXh0IGJhZGdlLiAqL1xyXG5leHBvcnQgZGVjbGFyZSBjbGFzcyBNYXRCYWRnZSBleHRlbmRzIF9NYXRCYWRnZU1peGluQmFzZSBpbXBsZW1lbnRzIE9uRGVzdHJveSwgT25DaGFuZ2VzLCBDYW5EaXNhYmxlIHtcclxuICAgIHByaXZhdGUgX25nWm9uZTtcclxuICAgIHByaXZhdGUgX2VsZW1lbnRSZWY7XHJcbiAgICBwcml2YXRlIF9hcmlhRGVzY3JpYmVyO1xyXG4gICAgcHJpdmF0ZSBfcmVuZGVyZXI7XHJcbiAgICBwcml2YXRlIF9hbmltYXRpb25Nb2RlPztcclxuICAgIC8qKiBXaGV0aGVyIHRoZSBiYWRnZSBoYXMgYW55IGNvbnRlbnQuICovXHJcbiAgICBfaGFzQ29udGVudDogYm9vbGVhbjtcclxuICAgIC8qKiBUaGUgY29sb3Igb2YgdGhlIGJhZGdlLiBDYW4gYmUgYHByaW1hcnlgLCBgYWNjZW50YCwgb3IgYHdhcm5gLiAqL1xyXG4gICAgZ2V0IGNvbG9yKCk6IFRoZW1lUGFsZXR0ZTtcclxuICAgIHNldCBjb2xvcih2YWx1ZTogVGhlbWVQYWxldHRlKTtcclxuICAgIHByaXZhdGUgX2NvbG9yO1xyXG4gICAgLyoqIFdoZXRoZXIgdGhlIGJhZGdlIHNob3VsZCBvdmVybGFwIGl0cyBjb250ZW50cyBvciBub3QgKi9cclxuICAgIGdldCBvdmVybGFwKCk6IGJvb2xlYW47XHJcbiAgICBzZXQgb3ZlcmxhcCh2YWw6IGJvb2xlYW4pO1xyXG4gICAgcHJpdmF0ZSBfb3ZlcmxhcDtcclxuICAgIC8qKlxyXG4gICAgICogUG9zaXRpb24gdGhlIGJhZGdlIHNob3VsZCByZXNpZGUuXHJcbiAgICAgKiBBY2NlcHRzIGFueSBjb21iaW5hdGlvbiBvZiAnYWJvdmUnfCdiZWxvdycgYW5kICdiZWZvcmUnfCdhZnRlcidcclxuICAgICAqL1xyXG4gICAgcG9zaXRpb246IE1hdEJhZGdlUG9zaXRpb247XHJcbiAgICAvKiogVGhlIGNvbnRlbnQgZm9yIHRoZSBiYWRnZSAqL1xyXG4gICAgY29udGVudDogc3RyaW5nO1xyXG4gICAgLyoqIE1lc3NhZ2UgdXNlZCB0byBkZXNjcmliZSB0aGUgZGVjb3JhdGVkIGVsZW1lbnQgdmlhIGFyaWEtZGVzY3JpYmVkYnkgKi9cclxuICAgIGdldCBkZXNjcmlwdGlvbigpOiBzdHJpbmc7XHJcbiAgICBzZXQgZGVzY3JpcHRpb24obmV3RGVzY3JpcHRpb246IHN0cmluZyk7XHJcbiAgICBwcml2YXRlIF9kZXNjcmlwdGlvbjtcclxuICAgIC8qKiBTaXplIG9mIHRoZSBiYWRnZS4gQ2FuIGJlICdzbWFsbCcsICdtZWRpdW0nLCBvciAnbGFyZ2UnLiAqL1xyXG4gICAgc2l6ZTogTWF0QmFkZ2VTaXplO1xyXG4gICAgLyoqIFdoZXRoZXIgdGhlIGJhZGdlIGlzIGhpZGRlbi4gKi9cclxuICAgIGdldCBoaWRkZW4oKTogYm9vbGVhbjtcclxuICAgIHNldCBoaWRkZW4odmFsOiBib29sZWFuKTtcclxuICAgIHByaXZhdGUgX2hpZGRlbjtcclxuICAgIC8qKiBVbmlxdWUgaWQgZm9yIHRoZSBiYWRnZSAqL1xyXG4gICAgX2lkOiBudW1iZXI7XHJcbiAgICBwcml2YXRlIF9iYWRnZUVsZW1lbnQ7XHJcbiAgICBjb25zdHJ1Y3Rvcihfbmdab25lOiBOZ1pvbmUsIF9lbGVtZW50UmVmOiBFbGVtZW50UmVmPEhUTUxFbGVtZW50PiwgX2FyaWFEZXNjcmliZXI6IEFyaWFEZXNjcmliZXIsIF9yZW5kZXJlcjogUmVuZGVyZXIyLCBfYW5pbWF0aW9uTW9kZT86IHN0cmluZyB8IHVuZGVmaW5lZCk7XHJcbiAgICAvKiogV2hldGhlciB0aGUgYmFkZ2UgaXMgYWJvdmUgdGhlIGhvc3Qgb3Igbm90ICovXHJcbiAgICBpc0Fib3ZlKCk6IGJvb2xlYW47XHJcbiAgICAvKiogV2hldGhlciB0aGUgYmFkZ2UgaXMgYWZ0ZXIgdGhlIGhvc3Qgb3Igbm90ICovXHJcbiAgICBpc0FmdGVyKCk6IGJvb2xlYW47XHJcbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKTogdm9pZDtcclxuICAgIG5nT25EZXN0cm95KCk6IHZvaWQ7XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIGVsZW1lbnQgaW50byB3aGljaCB0aGUgYmFkZ2UncyBjb250ZW50IGlzIGJlaW5nIHJlbmRlcmVkLlxyXG4gICAgICogVW5kZWZpbmVkIGlmIHRoZSBlbGVtZW50IGhhc24ndCBiZWVuIGNyZWF0ZWQgKGUuZy4gaWYgdGhlIGJhZGdlIGRvZXNuJ3QgaGF2ZSBjb250ZW50KS5cclxuICAgICAqL1xyXG4gICAgZ2V0QmFkZ2VFbGVtZW50KCk6IEhUTUxFbGVtZW50IHwgdW5kZWZpbmVkO1xyXG4gICAgLyoqIEluamVjdHMgYSBzcGFuIGVsZW1lbnQgaW50byB0aGUgRE9NIHdpdGggdGhlIGNvbnRlbnQuICovXHJcbiAgICBwcml2YXRlIF91cGRhdGVUZXh0Q29udGVudDtcclxuICAgIC8qKiBDcmVhdGVzIHRoZSBiYWRnZSBlbGVtZW50ICovXHJcbiAgICBwcml2YXRlIF9jcmVhdGVCYWRnZUVsZW1lbnQ7XHJcbiAgICAvKiogU2V0cyB0aGUgYXJpYS1sYWJlbCBwcm9wZXJ0eSBvbiB0aGUgZWxlbWVudCAqL1xyXG4gICAgcHJpdmF0ZSBfdXBkYXRlSG9zdEFyaWFEZXNjcmlwdGlvbjtcclxuICAgIC8qKiBBZGRzIGNzcyB0aGVtZSBjbGFzcyBnaXZlbiB0aGUgY29sb3IgdG8gdGhlIGNvbXBvbmVudCBob3N0ICovXHJcbiAgICBwcml2YXRlIF9zZXRDb2xvcjtcclxuICAgIC8qKiBDbGVhcnMgYW55IGV4aXN0aW5nIGJhZGdlcyB0aGF0IG1pZ2h0IGJlIGxlZnQgb3ZlciBmcm9tIHNlcnZlci1zaWRlIHJlbmRlcmluZy4gKi9cclxuICAgIHByaXZhdGUgX2NsZWFyRXhpc3RpbmdCYWRnZXM7XHJcbiAgICBzdGF0aWMgbmdBY2NlcHRJbnB1dFR5cGVfZGlzYWJsZWQ6IEJvb2xlYW5JbnB1dDtcclxuICAgIHN0YXRpYyBuZ0FjY2VwdElucHV0VHlwZV9oaWRkZW46IEJvb2xlYW5JbnB1dDtcclxuICAgIHN0YXRpYyBuZ0FjY2VwdElucHV0VHlwZV9vdmVybGFwOiBCb29sZWFuSW5wdXQ7XHJcbn1cclxuZXhwb3J0IHt9O1xyXG4iXX0=